# Challenge 2

Given in the handout 

```python
#!/usr/bin/env python3

from Crypto.Util.number import *
from flag import flag

def man(n):
	B = bin(n)[2:]
	M = ''
	for b in B:
		if b == '0':
			M += '01'
		else:
			M += '11'
	return int(M, 2)

def keygen(nbit):
	while True:
		p = getPrime(nbit)
		r = man(p)
		B = bin(p)[2:] + '1' * nbit
		q = int(B, 2)
		if isPrime(q) and isPrime(r):
				return q, r

nbit = 256
p, q = keygen(nbit)
m = bytes_to_long(flag)
assert m < n
e, n = 1234567891, p * q
c = pow(m, e, n)

print(f'n = {n}')
print(f'c = {c}') 
```
Output file 
```bash
n = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297  

c = 77151713996168344370880352082934801122524956107256445231326053049976568087412199358725058612262271922128984783428798480191211811217854076875727477848490840660333035334309193217618178091153472265093622822195960145852562781183839474868269109313543427082414220136748700364027714272845969723750108397300867408537
```


From the given python code it is evident that both p and q in some form are derived from the randomly generated prime so there is one unknown instead of 2.
- Leaking the prime would end the challenge
