#!/usr/bin/env python3
"""
exploit_final.py

- Solves PoW using the official solver (downloaded at runtime)
- Robustly discovers the secret path via recursive backtracking,
  trying all unused nodes at every step and parsing the server's
  JSON responses robustly.
- Saves errors_from_server.json and attempts LWE secret recovery
  using local lwe_pub_params.json (must be in same directory).
- Submits get_flag with recovered s and prints server response.

Files expected in cwd:
  - graph.json
  - lwe_pub_params.json

Usage:
  python3 exploit_final.py <host> <port>
"""

import socket
import re
import json
import time
import base64
import sys
import tempfile
import subprocess
import os
from copy import deepcopy

POW_URL = "https://goo.gle/kctf-pow"
MODULUS = 2**1279 - 1
TIMEOUT_SECONDS = 300  # LWE solver / DFS timeout

# ---------- Networking helpers ----------
def recv_all(sock, timeout=0.2):
    sock.settimeout(timeout)
    data = b''
    try:
        while True:
            part = sock.recv(4096)
            if not part:
                break
            data += part
    except socket.timeout:
        pass
    return data.decode(errors='ignore')

def send_line(sock, line):
    if not line.endswith("\n"):
        line = line + "\n"
    sock.sendall(line.encode())

def extract_last_json(text):
    """
    Find the last substring in 'text' that looks like a JSON object
    starting with '{' and ending with '}', and return it parsed, else None.
    Ignores lines that don't parse.
    """
    if not text:
        return None
    lines = text.strip().splitlines()
    for line in lines[::-1]:
        s = line.strip()
        # quick heuristic: must start with '{' and end with '}'
        if not s.startswith("{") or not s.endswith("}"):
            continue
        try:
            return json.loads(s)
        except Exception:
            continue
    # as a fallback, search within the whole text for {...} substrings (last occurrence)
    # This helps when banner and JSON are on the same line.
    matches = re.findall(r'(\{.*?\})', text, flags=re.DOTALL)
    for m in matches[::-1]:
        try:
            return json.loads(m)
        except Exception:
            continue
    return None

# ---------- PoW: use official solver ----------
def solve_pow_with_official(chal):
    tf = tempfile.NamedTemporaryFile(delete=False, suffix=".py")
    tf.close()
    try:
        # download official solver
        r = subprocess.run(["curl", "-sSL", POW_URL], stdout=open(tf.name, "wb"))
        proc = subprocess.run(["python3", tf.name, "solve", chal],
                              stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=600)
        out = proc.stdout.strip() + "\n" + proc.stderr.strip()
        # Try to extract the returned solution (could be 's.<...>' or full 's.xxx.yyy')
        m = re.search(r'(s\.[A-Za-z0-9+/=]+(?:\.[A-Za-z0-9+/=]+)?)', out)
        if m:
            return m.group(1)
        # Else return stdout raw if looks like s.
        if proc.stdout.strip().startswith("s."):
            return proc.stdout.strip()
        return None
    finally:
        try:
            os.remove(tf.name)
        except:
            pass

# ---------- Linear algebra for LWE ----------
def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def inv_mod(a, m):
    a %= m
    x, y, g = egcd(a, m)
    if g != 1:
        return None
    return x % m

def gauss_mod(A_rows, b_vec, q):
    A = [list(map(lambda v: v % q, row)) for row in A_rows]
    B = [v % q for v in b_vec]
    m = len(A); n = len(A[0]) if m > 0 else 0
    row = 0
    where = [-1] * n
    for col in range(n):
        sel = -1
        for r in range(row, m):
            if A[r][col] % q != 0:
                sel = r; break
        if sel == -1: continue
        A[row], A[sel] = A[sel], A[row]
        B[row], B[sel] = B[sel], B[row]
        inv = inv_mod(A[row][col], q)
        if inv is None:
            return None, 0
        for c in range(col, n):
            A[row][c] = (A[row][c] * inv) % q
        B[row] = (B[row] * inv) % q
        for r in range(m):
            if r != row and A[r][col] != 0:
                factor = A[r][col]
                for c in range(col, n):
                    A[r][c] = (A[r][c] - factor * A[row][c]) % q
                B[r] = (B[r] - factor * B[row]) % q
        where[col] = row
        row += 1
        if row == m: break
    for r in range(row, m):
        allzero = True
        for c in range(n):
            if A[r][c] % q != 0:
                allzero = False; break
        if allzero and (B[r] % q) != 0:
            return None, 0
    x = [0] * n
    for i in range(n):
        if where[i] != -1:
            x[i] = B[where[i]] % q
        else:
            x[i] = 0
    rank = row
    return [int(v) for v in x], rank

# ---------- LWE recovery using known |e| ----------
def recover_secret_from_public(A, b, abs_e, q, n, max_rows_to_use=None):
    m = len(A)
    max_rows_to_use = max_rows_to_use or m
    rhs_candidates = []
    for i in range(m):
        e = abs_e[i] % q
        rhs_plus = (b[i] - e) % q
        rhs_minus = (b[i] + e) % q
        rhs_candidates.append((rhs_plus, rhs_minus))
    order = list(range(m))
    order.sort(key=lambda i: abs_e[i])
    best = {"sol": None}
    start_time = time.time()
    TIMEOUT = TIMEOUT_SECONDS
    sys.setrecursionlimit(10000)
    def dfs(pos, selected_rows, selected_rhs):
        if time.time() - start_time > TIMEOUT:
            return False
        if len(selected_rows) >= n:
            A_sub = [A[r] for r in selected_rows]
            sol, rank = gauss_mod(A_sub, selected_rhs, q)
            if sol is not None and rank == n:
                ok = True
                for i in range(m):
                    lhs = sum((A[i][j] * sol[j]) for j in range(n)) % q
                    if lhs != rhs_candidates[i][0] and lhs != rhs_candidates[i][1]:
                        ok = False; break
                if ok:
                    best["sol"] = sol
                    return True
        if pos >= len(order) or len(selected_rows) >= max_rows_to_use:
            return False
        row_idx = order[pos]
        # plus
        selected_rows.append(row_idx)
        selected_rhs.append(rhs_candidates[row_idx][0])
        if dfs(pos + 1, selected_rows, selected_rhs): return True
        selected_rows.pop(); selected_rhs.pop()
        # minus
        selected_rows.append(row_idx)
        selected_rhs.append(rhs_candidates[row_idx][1])
        if dfs(pos + 1, selected_rows, selected_rhs): return True
        selected_rows.pop(); selected_rhs.pop()
        # skip
        if dfs(pos + 1, selected_rows, selected_rhs): return True
        return False
    ok = dfs(0, [], [])
    if ok and best["sol"] is not None:
        return best["sol"]
    return None

# ---------- Server interaction high-level ----------
def send_check_and_get_status(sock, segment, timeout=0.6):
    cmd = {"command": "check_path", "segment": segment}
    send_line(sock, json.dumps(cmd))
    # small sleep to let server respond
    time.sleep(0.03)
    resp = recv_all(sock, timeout=timeout)
    parsed = extract_last_json(resp)
    return parsed, resp

def find_full_path(sock, nodes):
    """
    Recursive backtracking discovery.
    At each step try all unused nodes; when server returns 'valid_prefix' for sent prefix,
    recurse; when 'path_complete' return the path and errors.
    """
    visited_prefixes = set()  # optional caching of tested prefixes as tuple
    sys.setrecursionlimit(10000)

    def backtrack(path):
        # stop if timeout externally
        prefix_key = tuple(path)
        if prefix_key in visited_prefixes:
            return None
        visited_prefixes.add(prefix_key)
        if len(path) == len(nodes):
            return None  # cannot be longer than full node count
        # try all unused nodes
        candidates = [n for n in nodes if n not in path]
        for c in candidates:
            candidate_seg = path + [c]
            parsed, raw = send_check_and_get_status(sock, candidate_seg)
            # debug: print minimal progress
            print(f"tried prefix {candidate_seg} -> parsed={None if parsed is None else parsed.get('status')}")
            if parsed is None:
                # No JSON - skip and continue
                continue
            st = parsed.get("status")
            if st == "valid_prefix":
                # recurse deeper
                res = backtrack(candidate_seg)
                if res is not None:
                    return res
                # if recursion didn't find complete, continue trying other candidates
            elif st == "path_complete":
                # success
                errors = parsed.get("lwe_error_magnitudes")
                return candidate_seg, errors
            else:
                # path_incorrect or error: continue
                continue
        return None

    return backtrack([])

# ---------- Main ----------
def main():
    if len(sys.argv) != 3:
        print("Usage: python3 exploit_final.py <host> <port>")
        sys.exit(1)
    host = sys.argv[1]; port = int(sys.argv[2])

    if not os.path.exists("graph.json"):
        print("graph.json missing. Place it here and re-run.")
        sys.exit(1)
    if not os.path.exists("lwe_pub_params.json"):
        print("lwe_pub_params.json missing. Place it here and re-run.")
        sys.exit(1)

    with open("graph.json") as f:
        graph = json.load(f)
    with open("lwe_pub_params.json") as f:
        pub = json.load(f)

    A = pub['A']; b = pub['b']; q = pub['lwe_q']; n = pub['lwe_n']; m = pub['lwe_m']
    nodes = sorted(map(int, graph.keys()))

    print("[*] Connecting to target {}:{} ...".format(host, port))
    sock = socket.create_connection((host, port), timeout=20)
    time.sleep(0.2)
    banner = recv_all(sock, timeout=1.0)
    print("[server banner]\n", banner)

    # extract PoW challenge
    mch = re.search(r'(s\.[A-Za-z0-9+/=]+\.[A-Za-z0-9+/=]+)', banner)
    if not mch:
        send_line(sock, "")  # nudge
        time.sleep(0.2)
        banner = recv_all(sock, timeout=1.0)
        mch = re.search(r'(s\.[A-Za-z0-9+/=]+\.[A-Za-z0-9+/=]+)', banner)
    if not mch:
        print("[!] Could not find PoW challenge in banner.")
        sock.close(); sys.exit(1)
    challenge = mch.group(1)
    print("[*] PoW challenge:", challenge)
    sol = solve_pow_with_official(challenge)
    if not sol:
        print("[!] Failed to solve PoW.")
        sock.close(); sys.exit(1)
    print("[*] Submitting PoW solution.")
    send_line(sock, sol)
    time.sleep(0.3)
    print("[after PoW]\n", recv_all(sock, timeout=1.0))

    print("[*] Starting robust recursive path discovery...")
    res = find_full_path(sock, nodes)
    if res is None:
        print("[!] Discovery failed (no path_complete found).")
        sock.close()
        sys.exit(1)

    full_path, abs_errors = res
    print("[+] PATH COMPLETE:", full_path)
    print("[+] Error magnitudes (len={}):".format(len(abs_errors)), abs_errors)
    with open("errors_from_server.json", "w") as f:
        json.dump(abs_errors, f)

    # Attempt LWE recovery
    print("[*] Attempting to recover LWE secret s (this may take some time)...")
    s_recovered = recover_secret_from_public(A, b, abs_errors, q, n)
    if s_recovered is None:
        print("[!] LWE secret recovery failed automatically. You can try other solver strategies.")
        sock.close(); sys.exit(1)
    print("[+] Recovered s (length {}):".format(len(s_recovered)))
    print(s_recovered)

    # Submit get_flag
    payload = {"command": "get_flag", "lwe_secret_s": s_recovered}
    send_line(sock, json.dumps(payload))
    time.sleep(0.4)
    flag_resp = recv_all(sock, timeout=2.0)
    print("[Flag response]\n", flag_resp)
    sock.close()

if __name__ == "__main__":
    main()

